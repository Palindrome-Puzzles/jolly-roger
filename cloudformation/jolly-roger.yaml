# This YAML file, when loaded and dumped as JSON, can be used as a
# CloudFormation Stack to spin up the jolly-roger environment. YAML is
# used instead of JSON for comments and easier-to-read formatting, but
# we should refrain from using any fancier features of YAML.
#
# The jolly-roger environment consists of:
#
# - A VPC with a public subnet (no support currently for private
#   subnets or NAT)
#
# - A system for fetching secrets using credstash which encrypts
#   secrets using KMS and stores them in DynamoDB.
#
# - An auto-scaling group (ASG) with instances that automatically
#   launch the jolly-roger application.
#
# - The application instances run several docker services:
#
#   - A registry to proxy access to private images
#
#   - An nginx instance for port 80, redirecting to HTTPS and
#     supporting the LetsEncrypt ACME verification process (via an S3
#     bucket)
#
#   - An nginx instance for port 8443, listening for HTTP connections
#     (HTTPS, unwrapped by ALB) and forwarding to the application
#
#   - The actual Meteor application
#
#   - Watchtower, which periodically pulls image updates
#
# - An Application Load Balancer (ALB) in front of the ASG, forwarding
#   ports 80 and 443 to ports 80 and 8443 on application servers. ALB
#   is responsible for terminating TLS (we require websocket support,
#   but ALB has that).
#
# It's possible this could be used to run multiple parallel copies of
# the jolly-roger website, though that's not very likely in practice.
#
# To spin up an independent copy of jolly-roger, you'll _definitely_
# need to do the following (and probably more I've forgotten):
#
# - Setup credstash (following the directions in the repo)
#
# - Generate the config.yml file for the registry. Starting with
#   http://git.io/vERX3, add a section labeled proxy. Include the keys
#   username and password with values for an account that has access
#   to the ebroder/jolly-roger image, and set remoteurl:
#   https://registry-1.docker.io. Store this using `credstash put
#   registry/config.yml @path`
#
# - Store the MongoDB URL using `credstash put mongo @<path>`. The
#   free account from mongolab (for instance) should be sufficient.

AWSTemplateFormatVersion: "2010-09-09"
Description: jolly-roger

Parameters:
  CredstashKeyUuid:
    Description: UUID of the credstash KMS key
    Type: String
  CertificateArn:
    Description: ARN of the certificate to use
    Type: String
  AppUrl:
    Description: The URL of application
    Type: String
    Default: future.deathandmayhem.com
  AppDomain:
    Description: The zone under which to create DNS records
    Type: AWS::Route53::HostedZone::Id
  AppInstanceType:
    Description: Instance type to run for app server
    Type: String
    Default: t2.micro
  AppMinSize:
    Description: Minimum number of instances for app server ASG
    Type: Number
    Default: 1
  AppMaxSize:
    Description: Maximum number of instances for app server ASG
    Type: Number
    Default: 2
  AppDesiredCapacity:
    Description: Desired number of instances for app server ASG
    Type: Number
    Default: 1
  PapertrailHost:
    Description: Log host for Papertrail
    Type: String
    Default: ''
    NoEcho: true
  DatadogApiKey:
    Description: API key for DataDog
    Type: String
    Default: ''
    NoEcho: true

Mappings:
  UbuntuAmis:
    us-east-1: {"ami": ami-2b594f41}

Conditions:
  HavePapertrail:
    Fn::Not:
      - Fn::Equals:
          - {Ref: PapertrailHost}
          - ''
  HaveDatadog:
    Fn::Not:
      - Fn::Equals:
          - {Ref: DatadogApiKey}
          - ''

Resources:
  VPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: 10.32.0.0/16
      EnableDnsHostnames: true

  PublicSubnetRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: {Ref: VPC}

  InternetGateway:
    Type: AWS::EC2::InternetGateway
  InternetGatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: {Ref: VPC}
      InternetGatewayId: {Ref: InternetGateway}
  PublicRouteToInternet:
    Type: AWS::EC2::Route
    Properties:
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: {Ref: InternetGateway}
      RouteTableId: {Ref: PublicSubnetRouteTable}

  PublicSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone: {"Fn::Select": [0, {"Fn::GetAZs": ""}]}
      CidrBlock: 10.32.0.0/24
      MapPublicIpOnLaunch: true
      VpcId: {Ref: VPC}
  PublicSubnet1RouteTableAssoc:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: {Ref: PublicSubnetRouteTable}
      SubnetId: {Ref: PublicSubnet1}

  PublicSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone: {"Fn::Select": [1, {"Fn::GetAZs": ""}]}
      CidrBlock: 10.32.1.0/24
      MapPublicIpOnLaunch: true
      VpcId: {Ref: VPC}
  PublicSubnet2RouteTableAssoc:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: {Ref: PublicSubnetRouteTable}
      SubnetId: {Ref: PublicSubnet2}

  # Bucket for serving /.well-known/acme-challenge/
  LetsEncryptBucket:
    Type: AWS::S3::Bucket
    Properties:
      AccessControl: PublicRead

  AppInstanceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: [ec2.amazonaws.com]
            Action: ["sts:AssumeRole"]
      Policies:
        - PolicyName: credstash-download
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:Query
                  - dynamodb:Scan
                Resource:
                  - Fn::Join:
                      - ""
                      -
                        - "arn:aws:dynamodb:"
                        - {Ref: "AWS::Region"}
                        - ":"
                        - {Ref: "AWS::AccountId"}
                        - ":table/credential-store"
              - Effect: Allow
                Action:
                  - kms:Decrypt
                Resource:
                  - Fn::Join:
                      - ""
                      -
                        - "arn:aws:kms:"
                        - {Ref: "AWS::Region"}
                        - ":"
                        - {Ref: "AWS::AccountId"}
                        - ":key/"
                        - {Ref: CredstashKeyUuid}

  AppInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: /
      Roles:
        - {Ref: AppInstanceRole}

  AppAlbSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for app load balancer
      SecurityGroupEgress: []
      SecurityGroupIngress:
        - CidrIp: 0.0.0.0/0
          IpProtocol: tcp
          FromPort: 80
          ToPort: 80
        - CidrIp: 0.0.0.0/0
          IpProtocol: tcp
          FromPort: 443
          ToPort: 443
      VpcId: {Ref: VPC}
  AppSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for app server instances
      SecurityGroupEgress:
        - CidrIp: 0.0.0.0/0
          IpProtocol: -1
          FromPort: -1
          ToPort: -1
      SecurityGroupIngress:
        - CidrIp: 0.0.0.0/0
          IpProtocol: tcp
          FromPort: 22
          ToPort: 22
        - SourceSecurityGroupId: {Ref: AppAlbSecurityGroup}
          IpProtocol: tcp
          FromPort: 80
          ToPort: 80
        - SourceSecurityGroupId: {Ref: AppAlbSecurityGroup}
          IpProtocol: tcp
          FromPort: 8443
          ToPort: 8443
        # echo request
        - CidrIp: 0.0.0.0/0
          IpProtocol: icmp
          FromPort: 8
          ToPort: -1
        # echo reply
        - CidrIp: 0.0.0.0/0
          IpProtocol: icmp
          FromPort: 0
          ToPort: -1
        # frag needed
        - CidrIp: 0.0.0.0/0
          IpProtocol: icmp
          FromPort: 3
          ToPort: 4
      VpcId: {Ref: VPC}

  AppAlb:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Scheme: internet-facing
      Subnets:
        - {Ref: PublicSubnet1}
        - {Ref: PublicSubnet2}
      SecurityGroups:
        - {Ref: AppAlbSecurityGroup}
  AppAlbTargetHTTP:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckProtocol: HTTP
      HealthCheckPort: 80
      HealthCheckPath: /healthcheck
      HealthCheckIntervalSeconds: 5
      HealthCheckTimeoutSeconds: 4
      HealthyThresholdCount: 2
      UnhealthyThresholdCount: 2
      Protocol: HTTP
      Port: 80
      VpcId: {Ref: VPC}
  AppAlbTargetHTTPS:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckProtocol: HTTP
      HealthCheckPort: 80
      HealthCheckPath: /healthcheck
      HealthCheckIntervalSeconds: 5
      HealthCheckTimeoutSeconds: 4
      HealthyThresholdCount: 2
      UnhealthyThresholdCount: 2
      Protocol: HTTP
      Port: 8443
      VpcId: {Ref: VPC}
  AppAlbListenerHTTP:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      LoadBalancerArn: {Ref: AppAlb}
      Protocol: HTTP
      Port: 80
      DefaultActions:
        - Type: forward
          TargetGroupArn: {Ref: AppAlbTargetHTTP}
  AppAlbListenerHTTPS:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      LoadBalancerArn: {Ref: AppAlb}
      Protocol: HTTPS
      Port: 443
      Certificates:
        - {CertificateArn: {Ref: CertificateArn}}
      DefaultActions:
        - Type: forward
          TargetGroupArn: {Ref: AppAlbTargetHTTPS}

  AppLaunchConfig:
    Type: AWS::AutoScaling::LaunchConfiguration
    Properties:
      IamInstanceProfile: {Ref: AppInstanceProfile}
      ImageId: 
        Fn::FindInMap:
          - UbuntuAmis
          - {Ref: "AWS::Region"}
          - ami
      BlockDeviceMappings:
        - DeviceName: /dev/sda1
          Ebs:
            VolumeSize: 12
        - DeviceName: /dev/sdb
          VirtualName: ephemeral0
        - DeviceName: /dev/sdc
          VirtualName: ephemeral1
        - DeviceName: /dev/sdf
          Ebs:
            VolumeType: gp2
            VolumeSize: 2
            DeleteOnTermination: true
      InstanceType: {Ref: AppInstanceType}
      SecurityGroups:
        - {Ref: AppSecurityGroup}
      # We're generating a YAML file inside a YAML file. Yes, this is
      # gross, but it seems to be the best anyone has come up with
      # (especially since we need variable interpolation)
      UserData:
        Fn::Base64:
          Fn::Join:
            - "\n"
            -
              - '#cloud-config'
              - ''
              - 'package_upgrade: true'
              - ''
              - 'apt_sources:'
              # For docker
              - '  - source: "deb https://apt.dockerproject.org/repo ubuntu-$RELEASE main"'
              - '    filename: docker.list'
              - '    keyid: 58118E89F3A912897C070ADBF76221572C52609D'
              - ''
              - 'users:'
              - '  - name: evan'
              - '    shell: /bin/bash'
              - '    ssh-import-id: gh:ebroder'
              - '    sudo: ALL=(ALL) NOPASSWD:ALL'
              - '  - name: zarvox'
              - '    shell: /bin/bash'
              - '    ssh-import-id: gh:zarvox'
              - '    sudo: ALL=(ALL) NOPASSWD:ALL'
              - '  - name: quentin'
              - '    shell: /bin/bash'
              - '    ssh-import-id: gh:quentinmit'
              - '    sudo: ALL=(ALL) NOPASSWD:ALL'
              - ''
              - 'mounts:'
              - '  - [/dev/xvdf, none, swap, sw, 0, 0]'
              - ''
              - 'packages:'
              - '  - docker-engine'
              - '  - htop'
              - '  - moreutils'
              - '  - python-dev'
              - '  - python-pip'
              - ''
              - Fn::If:
                  - HavePapertrail
                  - Fn::Join:
                      - ''
                      -
                        - "rsyslog:\n  - configs: [\". @"
                        - {Ref: PapertrailHost}
                        - "\"]"
                  - ''
              - ''
              - 'write_files:'
              - '  - path: /etc/cron.hourly/docker-cleanup'
              - '    content: |'
              - '      #!/bin/sh'
              - '      docker volume ls -qf dangling=true | chronic xargs -r docker volume rm'
              - '    permissions: "0755"'
              - '  - path: /etc/nginx-https/proxy.conf'
              - '    content: |'
              - '      proxy_cache_path /var/cache/nginx/cache levels=1:2 keys_zone=assets:10m;'
              - '      # HTTP 1.1 support'
              - '      proxy_http_version 1.1;'
              - '      proxy_buffering off;'
              - '      proxy_set_header Host $http_host;'
              - '      proxy_set_header Upgrade $http_upgrade;'
              - '      proxy_set_header Connection $proxy_connection;'
              - '      proxy_set_header X-Real-IP $remote_addr;'
              - '      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;'
              - '      proxy_set_header X-Forwarded-Proto $proxy_x_forwarded_proto;'
              - '      # Mitigate httpoxy attack (see README for details)'
              - '      proxy_set_header Proxy "";'
              - Fn::Join:
                  - ''
                  -
                    - '  - path: /etc/nginx-https/vhost.d/'
                    - {Ref: AppUrl}
              - '    content: |'
              - '      add_header Strict-Transport-Security "max-age=31536000";'
              - '      proxy_cache assets;'
              - '      gzip on;'
              - '      gzip_comp_level 9;'
              - '      gzip_proxied any;'
              - '  - path: /etc/nginx-http/conf.d/default.conf'
              - '    content: |'
              - '      server {'
              - '        listen 80;'
              - '        access_log /var/log/nginx/access.log main;'
              - '        location /.well-known/acme-challenge {'
              - Fn::Join:
                  - ''
                  -
                    - '          return 301 https://'
                    - {Ref: LetsEncryptBucket}
                    - '.s3.amazonaws.com$request_uri;'
              - '        }'
              - '        location /healthcheck {'
              - '          return 200 "OK\n";'
              - '        }'
              - '        location / {'
              - '          return 301 https://$host$request_uri;'
              - '        }'
              - '      }'
              - ''
              - 'runcmd:'
              - '  - set -eux'

              # Whatever happens, let cloudformation know
              - '  - pip install https://s3.amazonaws.com/cloudformation-examples/aws-cfn-bootstrap-latest.tar.gz'
              - Fn::Join:
                  - ''
                  -
                    - '  - cleanup() { ret=$?; set +e; cfn-signal -e $ret -r "runcmds complete" --stack='
                    - {Ref: "AWS::StackName"}
                    - ' --region='
                    - {Ref: "AWS::Region"}
                    - ' --resource=AppAsg; exit $ret; }'
              - '  - trap cleanup EXIT'

              - '  - mkswap /dev/xvdf'
              - '  - swapon -a'

              - '  - pip install credstash'
              - Fn::Join:
                  - ''
                  -
                    - '  - export AWS_DEFAULT_REGION='
                    - {Ref: "AWS::Region"}

              # Observability
              - Fn::If:
                  - HavePapertrail
                  - Fn::Join:
                      - ''
                      -
                        - '  - docker run --name logspout -d --restart=unless-stopped -v /var/run/docker.sock:/tmp/docker.sock gliderlabs/logspout:master syslog://'
                        - {Ref: PapertrailHost}
                  - {Ref: "AWS::NoValue"}
              - Fn::If:
                  - HaveDatadog
                  - Fn::Join:
                      - ''
                      -
                        - '  - docker run --name dd-agent -d --restart=unless-stopped -h `hostname` -v /var/run/docker.sock:/var/run/docker.sock -v /proc/:/host/proc/:ro -v /sys/fs/cgroup/:/host/sys/fs/cgroup:ro -e API_KEY='
                        - {Ref: DatadogApiKey}
                        - ' datadog/docker-dd-agent:latest'
                  - {Ref: "AWS::NoValue"}

              # Run a local registry proxy so we don't have to teach everything to auth for our private images
              - '  - mkdir -p /etc/docker/registry'
              - '  - credstash get registry/config.yml > /etc/docker/registry/config.yml'
              - '  - docker run --name registry -d --restart=unless-stopped -p 5000:5000 -v /etc/docker/registry:/etc/docker/registry registry:2'
              - '  - sleep 5'

              # Pre-fetch images
              - '  - docker pull localhost:5000/ebroder/jolly-roger'
              - '  - docker pull jwilder/nginx-proxy'
              - '  - docker pull centurylink/watchtower'

              - '  - docker run --name nginx-http -d --restart=unless-stopped -p 80:80 -v /etc/nginx-http/conf.d:/etc/nginx/conf.d nginx'

              - Fn::Join:
                  - ''
                  -
                    - '  - docker run --name jolly-roger -d --restart=unless-stopped -e AWS_DEFAULT_REGION=$AWS_DEFAULT_REGION'
                    - ' -e VIRTUAL_HOST='
                    - {Ref: AppUrl}
                    - ' -e ROOT_URL=https://'
                    - {Ref: AppUrl}
                    - ' localhost:5000/ebroder/jolly-roger'

              - Fn::Join:
                  - ''
                  -
                    - '  - docker run --name nginx-https -d --restart=unless-stopped -p 8443:80 -e DEFAULT_HOST='
                    - {Ref: AppUrl}
                    - ' -v /var/run/docker.sock:/tmp/docker.sock:ro -v /etc/nginx-https/proxy.conf:/etc/nginx/proxy.conf -v /etc/nginx-https/vhost.d:/etc/nginx/vhost.d jwilder/nginx-proxy'
              - '  - docker run --name watchtower -d --restart=unless-stopped -v /var/run/docker.sock:/var/run/docker.sock centurylink/watchtower --interval 30 --cleanup'
    DependsOn:
      - InternetGatewayAttachment

  AppAsg:
    Type: AWS::AutoScaling::AutoScalingGroup
    Properties:
      HealthCheckType: ELB
      HealthCheckGracePeriod: 1800
      LaunchConfigurationName: {Ref: AppLaunchConfig}
      VPCZoneIdentifier:
        - {Ref: PublicSubnet1}
        - {Ref: PublicSubnet2}
      MaxSize: {Ref: AppMaxSize}
      MinSize: {Ref: AppMinSize}
      DesiredCapacity: {Ref: AppDesiredCapacity}
      TargetGroupARNs:
        - {Ref: AppAlbTargetHTTP}
        - {Ref: AppAlbTargetHTTPS}
    UpdatePolicy:
      AutoScalingRollingUpdate:
        WaitOnResourceSignals: true
        PauseTime: PT30M
        MinSuccessfulInstancesPercent: 100
        MinInstancesInService: 1

  AppDns:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: {Ref: AppDomain}
      Name: {Ref: AppUrl}
      Type: A
      AliasTarget:
        HostedZoneId: {"Fn::GetAtt": [AppAlb, CanonicalHostedZoneID]}
        DNSName: {"Fn::GetAtt": [AppAlb, DNSName]}
