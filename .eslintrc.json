{
  "root": true,
  "parser": "@typescript-eslint/parser",
  "parserOptions": {
    "allowImportExportEverywhere": false,
    "tsconfigRootDir": ".",
    "project": "./tsconfig.json"
  },
  "plugins": [
    "filenames",
    "meteor",
    "@typescript-eslint",
    "deprecation"
  ],
  "extends": [
    "airbnb",
    "plugin:meteor/recommended",
    "plugin:import/errors",
    "plugin:import/warnings",
    "plugin:react-hooks/recommended",
    "plugin:eslint-comments/recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:@typescript-eslint/recommended-requiring-type-checking"
  ],
  "settings": {
    "import/resolver": {
      "meteor": {
        "extensions": [".js", ".jsx", ".ts", ".tsx"]
      },
      "typescript": {
        "extensions": [".js", ".jsx", ".ts", ".tsx"]
      }
    }
  },
  "rules": {
    // explicit returns can sometimes be more readable and avoid the issue of "I want to return an
    // object literal but ES6 interprets it as a function body with a void expression"
    "arrow-body-style": ["off"],

    // Publish functions don't really need to be named.
    "func-names": ["off"],

    // For Match expressions
    "new-cap": ["error", { "capIsNewExceptions": ["Optional", "OneOf", "Maybe", "ObjectIncluding"] }],

    // sometimes else after a return reads more clearly
    "no-else-return": ["off"],

     // We sometimes use these in various forms
    "no-underscore-dangle": ["error",
      {
        "allow": [
          "_id", "_this", "_dropIndex", "_redirectUri", "_postRequest",
          "_anyMethodsAreOutstanding", "_schemaKeys", "_schema", "_retrieveCredentialSecret"
        ]
      }
    ],
    "camelcase": ["error", {
      "properties": "never",
      "allow": ["__meteor_runtime_config__"]
    }],

    // We have files with multiple React components.  Maybe we should split them out
    // later, but right now I don't want to deal with this
    "react/no-multi-comp": ["off"],
    "max-classes-per-file": ["off"],

    // Absolute imports work with Meteor, but aren't well-understood by IDEs, like VS Code
    "import/no-absolute-path": ["error"],

    // We don't use imports with extensions
    "import/extensions": ["error", "never"],

    // Imports should be grouped, and sorted within the group. Meteor imports
    // are their own group, after built-ins and before other external libraries
    "import/order": ["error", {
      "alphabetize": {"order": "asc"},
      "pathGroups": [{
        "pattern": "meteor/**",
        "group": "external",
        "position": "before"
      }],
      "pathGroupsExcludedImportTypes": ["builtin"],
      "newlines-between": "never"
    }],

    // Files with default exports should be named to match them
    "filenames/match-exported": ["error"],

    // This is complaining a lot and I don't really want to write dozens of lines of
    // default prop values of `undefined`
    "react/require-default-props": ["off"],

    // We use spread props a lot for HOCs or other wrapper-type components
    "react/jsx-props-no-spreading": ["off"],

    // The eslint guide seems to claim that adding "static" to method
    // definitions is a noop, but that doesn't seem to be true in practice, and I
    // don't understand the prototype model well enough to understand why.
    "class-methods-use-this": ["off"],

    // Allow tsx files
    "react/jsx-filename-extension": [1, { "extensions": [".jsx", ".tsx"] }],

    // "name" is a useful variable
    "no-restricted-globals": ["off"],

    // Detect missing deps for non-standard hooks
    "react-hooks/exhaustive-deps": ["warn", { "additionalHooks": "useTracker|useFind" }],

    // Allow disabling eslint rules on more than a single line, but only across a whole file
    "eslint-comments/disable-enable-pair": ["error", { "allowWholeFile": true }],

    // Allow void statements to explicitly tag when we're throwing away a promise
    "no-void": ["error", { "allowAsStatement": true }],

    // Relax typescript checks to accommodate existing code
    "@typescript-eslint/no-non-null-assertion": "off",
    "@typescript-eslint/no-unsafe-argument": "off",
    "@typescript-eslint/no-unsafe-assignment": "off",
    "@typescript-eslint/no-unsafe-call": "off",
    "@typescript-eslint/no-unsafe-member-access": "off",
    "@typescript-eslint/no-unsafe-return": "off",
    "@typescript-eslint/no-explicit-any": "off",
    "@typescript-eslint/restrict-template-expressions": "off",
    "@typescript-eslint/no-unused-vars": ["error", { "argsIgnorePattern": "^_", "varsIgnorePattern": "^_" }],
    "@typescript-eslint/no-namespace": "off",
    "@typescript-eslint/prefer-namespace-keyword": ["off"],

    // Enable a subset of strict rules that are useful
    "@typescript-eslint/prefer-includes": ["error"],
    "@typescript-eslint/prefer-optional-chain": ["error"],
    "@typescript-eslint/prefer-nullish-coalescing": ["error"],

    // Enforce safety around promises
    "no-return-await": "off",
    "@typescript-eslint/return-await": "error",

    // Show errors for deprecated code
    "deprecation/deprecation": "error",

    // Match existing style
    "operator-linebreak": ["error", "after"],
    "prefer-destructuring": ["off"],
    "comma-dangle": ["error", {
      "arrays": "always-multiline",
      "objects": "always-multiline",
      "imports": "always-multiline",
      "exports": "always-multiline",
      "functions": "ignore"
    }],
    "no-plusplus": ["error", { "allowForLoopAfterthoughts": true }],
    "react/function-component-definition": ["error", {
      "namedComponents": "arrow-function"
    }],
    "jsx-a11y/accessible-emoji": ["off"],
    "jsx-a11y/click-events-have-key-events": ["off"],
    "jsx-a11y/no-static-element-interactions": ["off"],
    "jsx-a11y/media-has-caption": ["off"]
  },
  "overrides": [
    {
      "files": ["*.ts", "*.tsx"],
      "rules": {
        // this seems to catch interface definitions
        "no-undef": "off",
        // seems to not work for imports that are only used for typing
        "no-unused-vars": "off",

        // The Javascript versions of these rules don't handle TypeScript
        // scoping correctly, so use the TypeScript-specific ones instead
        "no-use-before-define": "off",
        "@typescript-eslint/no-use-before-define": "error",

        "no-shadow": "off",
        "@typescript-eslint/no-shadow": "error"
      }
    },
    {
      "files": "types/**",
      "rules": {
        // type declarations for other libraries don't get to choose their
        // export structure
        "import/prefer-default-export": ["off"]
      }
    },
    {
      "files": "tests/**",
      "rules": {
        // arrow functions with mocha are discouraged
        "func-names": "off",
        "prefer-arrow-callback": "off",

        // since tests run in both client and server context, sometimes we need
        // conditional imports, which can only be easily done with require
        "global-require": "off",
        "@typescript-eslint/no-var-requires": "off"
      }
    }
  ]
}
